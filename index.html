<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flappy Cat</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background: linear-gradient(to bottom, #87ceeb 0%, #fff 100%);
      font-family: Arial, sans-serif;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: transparent;
      touch-action: manipulation;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    (() => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      // Resize canvas to window size, with fallback defaults
      function resize() {
        canvas.width = window.innerWidth || 800;
        canvas.height = window.innerHeight || 600;
      }
      resize();
      window.addEventListener('resize', resize);

      // Game variables
      const gravity = 0.5;
      const flapPower = -9;
      const catSize = 40;
      const catX = 80;

      let catY = canvas.height / 2;
      let catVelocity = 0;
      let pipes = [];
      const pipeWidth = 60;
      const pipeGap = 200;
      const pipeSpeed = 3;

      let score = 0;
      let gameOver = false;

      // Input handler
      function flap() {
        if (gameOver) reset();
        else catVelocity = flapPower;
      }
      document.addEventListener('keydown', e => {
        if (e.code === 'Space') flap();
      });
      canvas.addEventListener('mousedown', flap);
      canvas.addEventListener('touchstart', e => { e.preventDefault(); flap(); }, { passive: false });

      // Create pipes with top pipe height randomized
      function addPipe() {
        const minPipeHeight = 50;
        const maxPipeHeight = canvas.height - pipeGap - minPipeHeight;
        const topHeight = Math.random() * (maxPipeHeight - minPipeHeight) + minPipeHeight;
        pipes.push({ x: canvas.width, topHeight, passed: false });
      }

      // Reset game state
      function reset() {
        catY = canvas.height / 2;
        catVelocity = 0;
        pipes = [];
        score = 0;
        gameOver = false;
        addPipe();
      }

      // Draw a simple cat (pixel-art style)
      function drawCat(x, y) {
        ctx.save();
        ctx.translate(x, y);

        // Body
        ctx.fillStyle = '#FF8C00'; // orange cat
        ctx.fillRect(0, 0, catSize, catSize);

        // Ears
        ctx.fillStyle = '#FFA500';
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(15, 0);
        ctx.lineTo(10, -10);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(catSize - 5, 0);
        ctx.lineTo(catSize - 15, 0);
        ctx.lineTo(catSize - 10, -10);
        ctx.closePath();
        ctx.fill();

        // Eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(12, 15, 5, 0, Math.PI * 2);
        ctx.arc(28, 15, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      // Draw pipe (brown scratching post style)
      function drawPipe(x, topHeight) {
        ctx.fillStyle = '#8B4513';
        // Top pipe
        ctx.fillRect(x, 0, pipeWidth, topHeight);
        // Bottom pipe
        ctx.fillRect(x, topHeight + pipeGap, pipeWidth, canvas.height - (topHeight + pipeGap));
      }

      // Update game objects
      function update() {
        if (gameOver) return;

        catVelocity += gravity;
        catY += catVelocity;

        if (catY + catSize > canvas.height || catY < 0) {
          gameOver = true;
        }

        for (let pipe of pipes) {
          pipe.x -= pipeSpeed;

          // Collision detection with cat rectangle and pipes
          if (
            catX + catSize > pipe.x &&
            catX < pipe.x + pipeWidth &&
            (catY < pipe.topHeight || catY + catSize > pipe.topHeight + pipeGap)
          ) {
            gameOver = true;
          }

          // Score counting
          if (!pipe.passed && pipe.x + pipeWidth < catX) {
            score++;
            pipe.passed = true;
          }
        }

        // Remove offscreen pipes
        pipes = pipes.filter(pipe => pipe.x + pipeWidth > 0);

        // Add pipes
        if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 300) {
          addPipe();
        }
      }

      // Draw everything
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Background (sky gradient handled by CSS)

        // Draw pipes
        for (let pipe of pipes) {
          drawPipe(pipe.x, pipe.topHeight);
        }

        // Draw cat
        drawCat(catX, catY);

        // Score text
        ctx.fillStyle = '#000';
        ctx.font = '32px Arial';
        ctx.fillText(`Score: ${score}`, 20, 50);

        // Game over message
        if (gameOver) {
          ctx.fillStyle = 'red';
          ctx.font = '48px Arial';
          ctx.fillText('Game Over!', canvas.width / 2 - 120, canvas.height / 2);
          ctx.font = '24px Arial';
          ctx.fillText('Tap or Space to restart', canvas.width / 2 - 130, canvas.height / 2 + 40);
        }
      }

      // Main game loop
      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }

      // Start game
      reset();
      loop();

    })();
  </script>
</body>
</html>

