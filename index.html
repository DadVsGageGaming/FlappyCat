<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Flappy Cat with Dogs</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: linear-gradient(to bottom, #87ceeb 0%, #fff 100%);
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    font-family: Arial, sans-serif;
  }
  canvas {
    display: block;
    margin: 0 auto;
    touch-action: manipulation;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function resize() {
    canvas.width = window.innerWidth || 800;
    canvas.height = window.innerHeight || 600;
  }
  resize();
  window.addEventListener('resize', resize);

  // Game variables
  const gravity = 0.5;
  const flapPower = -9;
  const catSize = 60;
  const catX = 80;

  let catY = canvas.height / 2;
  let catVelocity = 0;
  let pipes = [];
  const pipeWidth = 80;
  const pipeGap = 200;
  const pipeSpeed = 3;

  let score = 0;
  let gameOver = false;

  // Load images
  const catImg = new Image();
  catImg.src = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRS0IQhVr9DDJCq61QX28zCoiqDrvezBh5ylw&s";

  const dogImgUrls = [
    "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRNZJ_RBD0IDHxbtkzIIksOye4ypSvPMFgXlg&s",
    "https://static.vecteezy.com/system/resources/thumbnails/018/871/732/small_2x/cute-and-happy-dog-png.png",
    "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS4GA8fjB5zYPwpvr7CUTo1k-WK08iRoAu2mg&s"
  ];
  const dogImages = [];

  // Preload dog images + cat
  let loadedImages = 0;
  function imageLoaded() {
    loadedImages++;
    if (loadedImages === dogImgUrls.length + 1) {
      reset();
      loop();
    }
  }

  catImg.onload = imageLoaded;
  dogImgUrls.forEach(url => {
    const img = new Image();
    img.src = url;
    img.onload = imageLoaded;
    dogImages.push(img);
  });

  // Input handler
  function flap() {
    if (gameOver) reset();
    else catVelocity = flapPower;
  }
  document.addEventListener('keydown', e => {
    if (e.code === 'Space') flap();
  });
  canvas.addEventListener('mousedown', flap);
  canvas.addEventListener('touchstart', e => { e.preventDefault(); flap(); }, { passive: false });

  // Create pipes with top pipe height randomized, with random dog images for top/bottom
  function addPipe() {
    const minPipeHeight = 50;
    const maxPipeHeight = canvas.height - pipeGap - minPipeHeight;
    const topHeight = Math.random() * (maxPipeHeight - minPipeHeight) + minPipeHeight;
    const topDog = dogImages[Math.floor(Math.random() * dogImages.length)];
    const bottomDog = dogImages[Math.floor(Math.random() * dogImages.length)];
    pipes.push({ x: canvas.width, topHeight, passed: false, topDog, bottomDog });
  }

  // Reset game state
  function reset() {
    catY = canvas.height / 2;
    catVelocity = 0;
    pipes = [];
    score = 0;
    gameOver = false;
    addPipe();
  }

  // Draw cat sprite
  function drawCat(x, y) {
    ctx.drawImage(catImg, x, y, catSize, catSize);
  }

  // Draw dog pipes
  function drawPipe(pipe) {
    ctx.drawImage(pipe.topDog, pipe.x, 0, pipeWidth, pipe.topHeight);
    const bottomY = pipe.topHeight + pipeGap;
    const bottomHeight = canvas.height - bottomY;
    ctx.drawImage(pipe.bottomDog, pipe.x, bottomY, pipeWidth, bottomHeight);
  }

  // Update game state
  function update() {
    if (gameOver) return;

    catVelocity += gravity;
    catY += catVelocity;

    if (catY + catSize > canvas.height || catY < 0) {
      gameOver = true;
    }

    for (let pipe of pipes) {
      pipe.x -= pipeSpeed;

      // Collision detection
      if (
        catX + catSize > pipe.x &&
        catX < pipe.x + pipeWidth &&
        (catY < pipe.topHeight || catY + catSize > pipe.topHeight + pipeGap)
      ) {
        gameOver = true;
      }

      // Score update
      if (!pipe.passed && pipe.x + pipeWidth < catX) {
        score++;
        pipe.passed = true;
      }
    }

    // Remove offscreen pipes
    pipes = pipes.filter(pipe => pipe.x + pipeWidth > 0);

    // Add new pipes
    if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 300) {
      addPipe();
    }
  }

  // Draw everything
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw pipes
    for (let pipe of pipes) {
      drawPipe(pipe);
    }

    // Draw cat
    drawCat(catX, catY);

    // Score
    ctx.fillStyle = '#000';
    ctx.font = '36px Arial';
    ctx.fillText(`Score: ${score}`, 20, 50);

    if (gameOver) {
      ctx.fillStyle = 'red';
      ctx.font = '56px Arial';
      ctx.fillText('Game Over!', canvas.width / 2 - 140, canvas.height / 2);
      ctx.font = '24px Arial';
      ctx.fillText('Tap or Space to restart', canvas.width / 2 - 130, canvas.height / 2 + 50);
    }
  }

  // Main game loop
  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }
})();
</script>
</body>
</html>
